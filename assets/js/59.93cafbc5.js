(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{512:function(t,s,a){"use strict";a.r(s);var r=a(2),e=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"业务背景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#业务背景"}},[t._v("#")]),t._v(" 业务背景")]),t._v(" "),s("p",[t._v("线程1 定时扫描表A的需要处理的数据插入到表B\n线程2 读取表B的任务数据，并更新表A的数据，然后删除表B任务数据")]),t._v(" "),s("p",[t._v("极端情况下出现， 线程1查询完任务数据后->线程2更新表A数据->删除表B数据->线程1插入表B数据, 导致线程2已完成的任务，被重复插入")]),t._v(" "),s("h2",{attrs:{id:"解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),s("ol",[s("li",[t._v("加锁使两个线程的业务串行化执行，线程1查询之前加锁， 插入到表B后释放锁，线程2更新表A数据需要获取到锁，更新完释放锁")])]),t._v(" "),s("blockquote",[s("p",[t._v("线程2可能需要频繁更新 加锁导致效率低下")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("延迟删除，")])]),t._v(" "),s("blockquote",[s("p",[t._v("以上冲突的关键在于线程1 把线程2已完成的任务重复插入到表B中，因此在极端case下 即使线程1插入的数据是线程2已完成的任务，只需要保证线程2最终能将重复的任务删除即可")])]),t._v(" "),s("p",[t._v("具体实现: 删除表B数据更改为更新表B的删除标记，然后使用定时任务，如5分钟查询一次删除标记被更新2分钟以后进行删除")])])}),[],!1,null,null,null);s.default=e.exports}}]);