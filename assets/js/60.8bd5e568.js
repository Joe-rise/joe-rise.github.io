(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{504:function(e,n,s){"use strict";s.r(n);var t=s(2),i=Object(t.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"list-实现消息队列"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#list-实现消息队列"}},[e._v("#")]),e._v(" List 实现消息队列")]),e._v(" "),n("ul",[n("li",[e._v("使用LPUSH、RPOP 左进右出或RPUSH、LPOP 右进左出，实现消息顺序消费")]),e._v(" "),n("li",[e._v("使用 BLPOP、BRPOP 这种阻塞式读取的命令，实现消息及时消费")]),e._v(" "),n("li",[e._v("ack 机制  使用，使用index 读取list 的消息，正常消费完成后再使用POP删除")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("```java\n// 使用redission实现\n")])])]),n("p",[e._v("@Slf4j\n@Service\npublic class QueueService {")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('  @Autowired\n  private RedissonClient redissonClient;\n   \n  private static final String REDIS_MQ = "redisMQ";\n   \n  /**\n  * 发送消息到队列头部\n  *\n  * @param message\n  */\n  public void sendMessage(String message) {\n     RBlockingDeque<String> blockingDeque = redissonClient.getBlockingDeque(REDIS_MQ);\n   \n     try {\n           blockingDeque.putFirst(message);\n           log.info("将消息: {} 插入到队列。", message);\n     } catch (InterruptedException e) {\n           e.printStackTrace();\n     }\n  }\n   \n/**\n * 从队列尾部阻塞读取消息，若没有消息，线程就会阻塞等待新消息插入，防止 CPU 空转\n */\npublic void onMessage() {\n    RBlockingDeque<String> blockingDeque = redissonClient.getBlockingDeque(REDIS_MQ);\n    while (true) {\n        try {\n            String message = blockingDeque.takeLast();\n            log.info("从队列 {} 中读取到消息：{}.", REDIS_MQ, message);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n   \n    }\n}```\n')])])]),n("h2",{attrs:{id:"发布-订阅模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#发布-订阅模式"}},[e._v("#")]),e._v(" "),n("strong",[e._v("发布/订阅")]),e._v("模式")]),e._v(" "),n("p",[e._v('可以实现进程间的消息传递，其原理如下:\n"发布/订阅"模式包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或者多个频道(channel)，而发布者可以向指定的频道(channel)发送消息，所有订阅此频道的订阅者都会收到此消息。\n缺点： 无法实现消息持久化，没有订阅者者数据会被丢弃')]),e._v(" "),n("h2",{attrs:{id:"基于zset实现延时队列"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基于zset实现延时队列"}},[e._v("#")]),e._v(" 基于zset实现延时队列")]),e._v(" "),n("p",[e._v("zset 会按 score 进行排序，如果 score 代表想要执行时间的时间戳。在某个时间将它插入zset集合中，它变会按照时间戳大小进行排序，也就是对执行时间前后进行排序。\n起一个死循环线程不断地进行取第一个key值，如果当前时间戳大于等于该key值的socre就将它取出来进行消费删除，可以达到延时执行的目的。")]),e._v(" "),n("blockquote",[n("p",[e._v("zset命令")]),e._v(" "),n("ul",[n("li",[e._v("范围查询所有 zrange yuwen 0 -1 withscores")]),e._v(" "),n("li",[e._v("添加/更新 ZADD yuwen 90 s01 89 s03 99 s02 74 s04 97 s05")]),e._v(" "),n("li",[e._v("查询指定分数  ZSCORE yuwen s03")]),e._v(" "),n("li",[e._v("查询分数范围 ZRANGEBYSCORE yuwen 90 100 withscores")]),e._v(" "),n("li",[e._v("删除 ZREM myzset member1")])])])])}),[],!1,null,null,null);n.default=i.exports}}]);